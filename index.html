<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D 坐标系 演示（Three.js）</title>
  <style>
    html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    #app{height:100vh;display:flex;flex-direction:column}
    header{padding:10px 16px;background:#0b1220;color:#fff;display:flex;align-items:center;gap:12px}
    header h1{font-size:16px;margin:0}
    #container{flex:1;position:relative;background:#111}
    .legend{position:absolute;left:12px;top:12px;color:#fff;padding:8px 10px;background:rgba(0,0,0,0.4);border-radius:6px;font-size:13px}
    .footer{padding:8px 12px;background:#07101a;color:#9ec8ff;font-size:13px}
    canvas{display:block}
    .controls{display:flex;align-items:center;gap:6px;margin-left:auto}
    .controls button{appearance:none;border:1px solid #2a3b5f;background:#12213a;color:#e6f0ff;border-radius:6px;padding:6px 10px;font-size:12px;cursor:pointer}
    .controls button:hover{background:#183056}
    .controls .sep{width:1px;height:18px;background:#2a3b5f;margin:0 4px}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>3D 坐标系（Three.js）</h1>
      <div style="opacity:0.85">鼠标拖拽旋转，滚轮缩放，右键平移</div>
      <div class="controls">
        <button id="btn-up" title="上（↑ / W）">↑</button>
        <button id="btn-down" title="下（↓ / S）">↓</button>
        <button id="btn-left" title="左（← / A）">←</button>
        <button id="btn-right" title="右（→ / D）">→</button>
        <span class="sep"></span>
        <button id="btn-zoom-in" title="拉近（+ 或 =）">＋</button>
        <button id="btn-zoom-out" title="拉远（-）">－</button>
        <span class="sep"></span>
        <button id="btn-reset" title="重置（R 或 双击画布）">重置</button>
      </div>
    </header>

    <div id="container">
      <div class="legend">坐标系: X=红, Y=绿, Z=蓝（含正负方向）</div>
    </div>

    <div class="footer">生成：单文件 HTML（使用 Three.js）</div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.152.2';
    import { OrbitControls } from 'https://esm.sh/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { RoundedBoxGeometry } from 'https://esm.sh/three@0.152.2/examples/jsm/geometries/RoundedBoxGeometry.js';

    window.addEventListener('DOMContentLoaded', () => {
      const container = document.getElementById('container');
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1220);

      const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(6, 6, 6);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.target.set(0,0,0);

      const grid = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
      grid.rotation.x = Math.PI / 2;
      scene.add(grid);

      const centerGeom = new THREE.SphereGeometry(0.06, 16, 12);
      const centerMat = new THREE.MeshStandardMaterial({ color: 0xffdd55, metalness:0.2, roughness:0.6 });
      const centerMesh = new THREE.Mesh(centerGeom, centerMat);
      scene.add(centerMesh);

      const amb = new THREE.AmbientLight(0xffffff, 0.45);
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 0.7);
      dir.position.set(5,10,7);
      scene.add(dir);

      function makeLabelSprite(text) {
        const size = 256;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0,0,size,size);
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'white';
        ctx.lineWidth = 6;
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.strokeText(text, size/2, size/2);
        ctx.fillText(text, size/2, size/2);
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false });
        const sprite = new THREE.Sprite(mat);
        sprite.scale.set(0.9,0.5,1.0);
        return sprite;
      }

      // 帮助线箭头：同时绘制正负方向
      function makeArrow(dirVec, color, labelText){
        const group = new THREE.Group();
        const length = 5;
        const lineGeom = new THREE.BufferGeometry().setFromPoints([
          dirVec.clone().multiplyScalar(-length),
          dirVec.clone().multiplyScalar(length)
        ]);
        const lineMat = new THREE.LineBasicMaterial({ color });
        const line = new THREE.Line(lineGeom, lineMat);
        group.add(line);

        // 正向箭头
        const coneGeom = new THREE.ConeGeometry(0.12, 0.4, 12);
        const coneMat = new THREE.MeshStandardMaterial({ color });
        const conePos = new THREE.Mesh(coneGeom, coneMat);
        conePos.position.copy(dirVec.clone().multiplyScalar(length + 0.2));
        conePos.lookAt(new THREE.Vector3(0,0,0));
        conePos.rotateX(Math.PI);
        group.add(conePos);

        // 负向箭头
        const coneNeg = new THREE.Mesh(coneGeom, coneMat);
        coneNeg.position.copy(dirVec.clone().multiplyScalar(-length - 0.2));
        coneNeg.lookAt(new THREE.Vector3(0,0,0));
        group.add(coneNeg);

        // 标签
        const label = makeLabelSprite(labelText);
        label.position.copy(dirVec.clone().multiplyScalar(length + 0.8));
        group.add(label);

        return group;
      }

      scene.add(makeArrow(new THREE.Vector3(1,0,0), 0xff0000, 'X'));
      scene.add(makeArrow(new THREE.Vector3(0,1,0), 0x00ff00, 'Y'));
      scene.add(makeArrow(new THREE.Vector3(0,0,1), 0x0000ff, 'Z'));

      const tickSize = 0.15;
      const tickStep = 1;
      const lengthAxis = 5;

      const ptsX = [];
      for(let i=-lengthAxis;i<=lengthAxis;i+=tickStep){ if(i===0) continue; ptsX.push(new THREE.Vector3(i,-tickSize,0), new THREE.Vector3(i,tickSize,0)); }
      const geoX = new THREE.BufferGeometry().setFromPoints(ptsX);
      const ticksX = new THREE.LineSegments(geoX, new THREE.LineBasicMaterial({ color: 0xff5555 }));
      scene.add(ticksX);

      const ptsY = [];
      for(let i=-lengthAxis;i<=lengthAxis;i+=tickStep){ if(i===0) continue; ptsY.push(new THREE.Vector3(-tickSize,i,0), new THREE.Vector3(tickSize,i,0)); }
      const geoY = new THREE.BufferGeometry().setFromPoints(ptsY);
      const ticksY = new THREE.LineSegments(geoY, new THREE.LineBasicMaterial({ color: 0x55ff55 }));
      scene.add(ticksY);

      const ptsZ = [];
      for(let i=-lengthAxis;i<=lengthAxis;i+=tickStep){ if(i===0) continue; ptsZ.push(new THREE.Vector3(-tickSize,0,i), new THREE.Vector3(tickSize,0,i)); }
      const geoZ = new THREE.BufferGeometry().setFromPoints(ptsZ);
      const ticksZ = new THREE.LineSegments(geoZ, new THREE.LineBasicMaterial({ color: 0x5555ff }));
      scene.add(ticksZ);

      const EPSZ = 1e-3;
      function isZPlane(a,b){
        return Math.abs(a.z) < EPSZ && Math.abs(b.z) < EPSZ;
      }

      function drawArrow(start, end, color){
        const thick = isZPlane(start, end);
        const dirVec = end.clone().sub(start);
        const len = dirVec.length();
        if(len <= 0.1) return;
        dirVec.normalize();
        const headLen = 0.35;
        const shaftLen = Math.max(0.05, len - headLen);
        const r = thick ? 0.04 : 0.015;
        const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), dirVec);
        const shaft = new THREE.Mesh(new THREE.CylinderGeometry(r, r, shaftLen, 12), new THREE.MeshStandardMaterial({ color, metalness:0.1, roughness:0.6 }));
        const shaftMid = start.clone().add(dirVec.clone().multiplyScalar(shaftLen/2));
        shaft.position.copy(shaftMid);
        shaft.quaternion.copy(quat);
        scene.add(shaft);
        const coneRad = thick ? r*2.2 : r*1.8;
        const head = new THREE.Mesh(new THREE.ConeGeometry(coneRad, headLen, 16), new THREE.MeshStandardMaterial({ color, metalness:0.1, roughness:0.6 }));
        const headCenter = start.clone().add(dirVec.clone().multiplyScalar(shaftLen + headLen/2));
        head.position.copy(headCenter);
        head.quaternion.copy(quat);
        scene.add(head);
      }

      function makeNode(text, position, color){
        const w = 0.8, h = 0.4, d = 0.09, r = 0.09;
        const box = new THREE.Mesh(new RoundedBoxGeometry(w, h, d, 4, r), new THREE.MeshStandardMaterial({ color, metalness:0.2, roughness:0.5 }));
        box.position.copy(position.clone());
        const label = makeLabelSprite(text);
        label.position.set(position.x, position.y, position.z + d*0.5 + 0.02);
        const group = new THREE.Group();
        group.add(box);
        group.add(label);
        return group;
      }

      const nodes = [
        { id:'api', text:'Gateway', pos:new THREE.Vector3(0,4,0), color:0x00c2ff },
        { id:'iam', text:'IAM', pos:new THREE.Vector3(-3,0,0), color:0x9b59b6 },
        { id:'shopping', text:'shopping', pos:new THREE.Vector3(-1,0,0), color:0x2ecc71 },
        { id:'cart', text:'cart', pos:new THREE.Vector3(1,0,0), color:0xf1c40f },
        { id:'pay', text:'pay', pos:new THREE.Vector3(3,0,0), color:0xe74c3c },
        { id:'flink', text:'flink', pos:new THREE.Vector3(0,4,-2), color:0x16a085 }
      ];

      const nodeMap = new Map();
      nodes.forEach(n=>{
        const g = makeNode(n.text, n.pos, n.color);
        scene.add(g);
        nodeMap.set(n.id, { ...n, group:g });
      });

      const origin = nodeMap.get('api').pos.clone();
      ['iam','shopping','cart','pay'].forEach(key=>{
        const dst = nodeMap.get(key).pos.clone();
        let a = origin.clone();
        let b = dst.clone();
        if(isZPlane(a,b)){ a.z += 0.01; b.z += 0.01; }
        drawArrow(a, b, 0x79c0ff);
      });

      ['api','iam','shopping','pay'].forEach(src=>{
        const srcPos = nodeMap.get(src).pos.clone();
        const dstPos = nodeMap.get('flink').pos.clone();
        let a = srcPos.clone();
        let b = dstPos.clone();
        if(isZPlane(a,b)){ a.z += 0.01; b.z += 0.01; }
        drawArrow(a, b, 0x79c0ff);
      });

      function onWindowResize(){
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w,h);
        camera.aspect = w/h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', onWindowResize, false);

      function animate(){
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
      const ROT_STEP = THREE.MathUtils.degToRad(10);
      const ZOOM_FACTOR = 0.85;
      const EPS = 1e-4;

      function applySpherical(deltaTheta = 0, deltaPhi = 0, radiusScale = 1){
        const target = controls.target.clone();
        const offset = camera.position.clone().sub(target);
        const sph = new THREE.Spherical().setFromVector3(offset);
        sph.theta += deltaTheta;
        sph.phi += deltaPhi;
        sph.phi = Math.max(EPS, Math.min(Math.PI - EPS, sph.phi));
        sph.radius = Math.max(0.1, sph.radius * radiusScale);
        camera.position.copy(new THREE.Vector3().setFromSpherical(sph).add(target));
        camera.lookAt(target);
        controls.update();
      }

      const $ = (id)=>document.getElementById(id);
      $("btn-up").addEventListener('click', ()=>applySpherical(0, -ROT_STEP, 1));
      $("btn-down").addEventListener('click', ()=>applySpherical(0, ROT_STEP, 1));
      $("btn-left").addEventListener('click', ()=>applySpherical(-ROT_STEP, 0, 1));
      $("btn-right").addEventListener('click', ()=>applySpherical(ROT_STEP, 0, 1));
      $("btn-zoom-in").addEventListener('click', ()=>applySpherical(0, 0, ZOOM_FACTOR));
      $("btn-zoom-out").addEventListener('click', ()=>applySpherical(0, 0, 1/ZOOM_FACTOR));
      $("btn-reset").addEventListener('click', ()=>{
        camera.position.set(6,6,6);
        controls.target.set(0,0,0);
        controls.update();
      });

      window.addEventListener('keydown', (e)=>{
        let handled = true;
        switch(e.key){
          case 'ArrowUp': case 'w': case 'W': applySpherical(0, -ROT_STEP, 1); break;
          case 'ArrowDown': case 's': case 'S': applySpherical(0, ROT_STEP, 1); break;
          case 'ArrowLeft': case 'a': case 'A': applySpherical(-ROT_STEP, 0, 1); break;
          case 'ArrowRight': case 'd': case 'D': applySpherical(ROT_STEP, 0, 1); break;
          case '+': case '=': applySpherical(0, 0, ZOOM_FACTOR); break;
          case '-': case '_': applySpherical(0, 0, 1/ZOOM_FACTOR); break;
          case 'r': case 'R':
            camera.position.set(6,6,6);
            controls.target.set(0,0,0);
            controls.update();
            break;
          default: handled = false;
        }
        if(handled){ e.preventDefault(); }
      }, { passive:false });

      container.addEventListener('dblclick', () => {
        camera.position.set(6,6,6);
        controls.target.set(0,0,0);
        controls.update();
      });
    });
  </script>
</body>
</html>
